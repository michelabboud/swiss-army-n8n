#!/usr/bin/env bash
set -Eeuo pipefail

#############################################
# stackctl.sh - Swiss-army Docker Compose control script
#
# Orchestrates a multi-service "lab" stack using docker compose.
# Supports:
#   - start / restart / stop / rebuild
#   - clean (down, with safe volume removal prompt)
#   - logs
#   - shell (exec into a single service)
#   - info
#   - status
#   - health (container + mounts overview)
#
# Target selection:
#   --all        (default) operate on all services
#   --profile P  limit to one or more profiles
#   --service S  limit to one or more services
#
# You can pass extra arguments to docker compose after "--".
#
# Versioning:
#   Bump SCRIPT_VERSION when behavior or interfaces change.
#############################################

SCRIPT_VERSION="0.1.1"  # bumped because behavior changed (command echoing)

# Defaults (can be overridden via flags or env)
COMPOSE_FILE_DEFAULT="${COMPOSE_FILE_DEFAULT:-docker-compose.yml}"
PROJECT_NAME_DEFAULT="${PROJECT_NAME_DEFAULT:-swiss-army-stack}"

COMPOSE_FILE="$COMPOSE_FILE_DEFAULT"
PROJECT_NAME="$PROJECT_NAME_DEFAULT"

# Target selection
TARGET_MODE="all"         # all | profile | service
PROFILES=()
SERVICES=()

# Extra args passed after "--" go directly to docker compose
FORWARDED_ARGS=()

# Colors (only if stdout is a TTY)
if [[ -t 1 ]]; then
  RED=$(tput setaf 1 || true)
  GREEN=$(tput setaf 2 || true)
  YELLOW=$(tput setaf 3 || true)
  BLUE=$(tput setaf 4 || true)
  BOLD=$(tput bold || true)
  RESET=$(tput sgr0 || true)
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; BOLD=""; RESET=""
fi

#############################################
# Helpers
#############################################

log()   { printf '%b\n' "${BLUE}[stackctl]${RESET} $*"; }
warn()  { printf '%b\n' "${YELLOW}[stackctl][WARN]${RESET} $*" >&2; }
error() { printf '%b\n' "${RED}[stackctl][ERROR]${RESET} $*" >&2; exit 1; }

trap 'error "Command failed (exit $?) at line $LINENO."' ERR

usage() {
  cat <<EOF
${BOLD}stackctl.sh${RESET} v${SCRIPT_VERSION}
Swiss-army control script for the swiss-army docker-compose stack.

${BOLD}Usage:${RESET}
  stackctl.sh <command> [options] [-- <extra docker compose args>]

${BOLD}Commands:${RESET}
  start       Bring up services (docker compose up -d)
  restart     Restart running services
  stop        Stop services (docker compose stop)
  rebuild     Rebuild images and restart (docker compose up --build -d)
  clean       Tear down containers (and optionally volumes)
  logs        Show logs (docker compose logs)
  shell       Open an interactive shell in a single service container
  info        Show stack and docker compose information
  status      Show docker compose ps
  health      Inspect containers: status, health, mounts

${BOLD}Target selection (applies to most commands):${RESET}
  --all               Operate on all services (default)
  --profile NAME      Limit to services in one or more profiles
                      Can be specified multiple times or as CSV:
                        --profile core --profile images
                        --profile core,images
  --service NAME      Limit to specific service(s) by name
                      Can be specified multiple times or as CSV:
                        --service n8n --service postgres
                        --service n8n,postgres

${BOLD}Global options:${RESET}
  -f, --file FILE         Use an alternate docker-compose file (default: ${COMPOSE_FILE_DEFAULT})
  -p, --project-name NAME Set docker compose project name (default: ${PROJECT_NAME_DEFAULT})
  --version               Show script version and exit
  -h, --help              Show this help and exit

${BOLD}Examples:${RESET}
  # Start core stack (assuming profiles defined in compose)
  stackctl.sh start --profile core

  # Start core + images profiles
  stackctl.sh start --profile core --profile images

  # Restart only n8n and postgres
  stackctl.sh restart --service n8n,postgres

  # View logs for AI-related services with follow
  stackctl.sh logs --profile ai -- -f

  # Interactive shell into the n8n container
  stackctl.sh shell --service n8n

  # Full health report for all running containers
  stackctl.sh health --all

  # Tear down everything (with a prompt about volumes)
  stackctl.sh clean --all

Note: Any arguments after "--" are passed directly to docker compose.
EOF
}

DOCKER_COMPOSE_CMD=()

detect_compose() {
  if command -v docker >/dev/null 2>&1; then
    if docker compose version >/dev/null 2>&1; then
      DOCKER_COMPOSE_CMD=(docker compose)
      return
    fi
  fi

  if command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD=(docker-compose)
    return
  fi

  error "Neither 'docker compose' nor 'docker-compose' is available on PATH."
}

compose() {
  detect_compose
  local profile_flags=()
  for p in "${PROFILES[@]}"; do
    profile_flags+=(--profile "$p")
  done

  # Build the full command as an array
  local full_cmd=(
    "${DOCKER_COMPOSE_CMD[@]}"
    -f "$COMPOSE_FILE"
    -p "$PROJECT_NAME"
    "${profile_flags[@]}"
    "$@"
  )

  # Pretty-print the exact command that will be executed
  printf '%b\n' "${BLUE}[stackctl][CMD]${RESET} ${full_cmd[*]}"

  # Execute it
  "${full_cmd[@]}"
}

set_target_mode() {
  local new_mode="$1"
  if [[ "$TARGET_MODE" != "all" && "$TARGET_MODE" != "$new_mode" ]]; then
    error "Cannot mix different target modes (e.g. --profile and --service)."
  fi
  TARGET_MODE="$new_mode"
}

parse_csv_append() {
  local csv="$1"; shift
  local -n _arr_ref="$1"  # nameref
  IFS=',' read -ra parts <<<"$csv"
  for p in "${parts[@]}"; do
    [[ -z "$p" ]] && continue
    _arr_ref+=("$p")
  done
}

#############################################
# Command implementations
#############################################

ensure_command_set() {
  if [[ -z "${CMD:-}" ]]; then
    usage
    error "Missing command."
  fi
}

cmd_start() {
  log "Starting services (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  compose up -d "${extra[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_restart() {
  log "Restarting services (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  compose restart "${extra[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_stop() {
  log "Stopping services (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  compose stop "${extra[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_rebuild() {
  log "Rebuilding images and starting services (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  compose up -d --build "${extra[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_clean() {
  if [[ "$TARGET_MODE" == "service" && "${#SERVICES[@]}" -gt 0 ]]; then
    warn "Clean in --service mode will remove only the selected services' containers."
    read -r -p "Proceed to remove containers for services: ${SERVICES[*]} ? [y/N] " ans
    if [[ ! "$ans" =~ ^[Yy]$ ]]; then
      log "Aborting clean for selected services."
      return
    fi
    compose rm -f "${SERVICES[@]}"
    log "Selected services removed."
    return
  fi

  warn "You are about to bring down the stack for project '${PROJECT_NAME}'."
  read -r -p "Proceed with docker compose down (containers and networks)? [y/N] " ans
  if [[ ! "$ans" =~ ^[Yy]$ ]]; then
    log "Aborting clean."
    return
  fi

  local down_args=(down --remove-orphans)
  read -r -p "Also remove named volumes for this project? [y/N] " v_ans
  if [[ "$v_ans" =~ ^[Yy]$ ]]; then
    down_args+=(--volumes)
  fi

  log "Running docker compose down (with arguments: ${down_args[*]})"
  compose "${down_args[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_logs() {
  log "Showing logs (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  compose logs "${extra[@]}" "${FORWARDED_ARGS[@]}"
}

cmd_shell() {
  if [[ "${#SERVICES[@]}" -ne 1 ]]; then
    error "shell command requires exactly one service via --service NAME."
  fi
  local svc="${SERVICES[0]}"
  log "Opening shell in service '${svc}'..."
  local cid
  cid=$(compose ps -q "$svc")
  if [[ -z "$cid" ]]; then
    error "No running container found for service '$svc'. Start it first."
  fi

  # Decide shell: bash if available, else sh
  local shell_cmd="bash"
  if ! docker exec "$cid" bash -lc 'exit 0' >/dev/null 2>&1; then
    shell_cmd="sh"
  fi

  printf '%b\n' "${BLUE}[stackctl][CMD]${RESET} docker exec -it ${cid} ${shell_cmd}"

  docker exec -it "$cid" "$shell_cmd"
}

cmd_info() {
  log "Project info"
  printf '  %sProject name:%s   %s\n' "$BOLD" "$RESET" "$PROJECT_NAME"
  printf '  %sCompose file:%s   %s\n' "$BOLD" "$RESET" "$COMPOSE_FILE"
  printf '  %sTarget mode:%s    %s\n' "$BOLD" "$RESET" "$TARGET_MODE"

  if [[ "${#PROFILES[@]}" -gt 0 ]]; then
    printf '  %sProfiles:%s       %s\n' "$BOLD" "$RESET" "${PROFILES[*]}"
  else
    printf '  %sProfiles:%s       (none specified; default compose behavior)\n' "$BOLD" "$RESET"
  fi

  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    printf '  %sServices:%s       %s\n' "$BOLD" "$RESET" "${SERVICES[*]}"
  fi

  echo
  log "Declared services (from docker compose config):"
  compose config --services | sed 's/^/  - /'

  echo
  log "Current container status:"
  compose ps
}

cmd_status() {
  log "Stack status (docker compose ps)..."
  compose ps "${FORWARDED_ARGS[@]}"
}

cmd_health() {
  log "Health & mounts overview (mode: ${TARGET_MODE})..."
  local extra=()
  if [[ "${#SERVICES[@]}" -gt 0 ]]; then
    extra=("${SERVICES[@]}")
  fi
  local ids
  if ! ids=$(compose ps -q "${extra[@]}"); then
    warn "Failed to list containers (are any services started?)"
    return 1
  fi
  if [[ -z "$ids" ]]; then
    warn "No containers found for the selected target."
    return 0
  fi

  for id in $ids; do
    local name status health
    name=$(docker inspect --format '{{.Name}}' "$id" | sed 's#^/##')
    status=$(docker inspect --format '{{.State.Status}}' "$id")
    health=$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{end}}' "$id")

    local status_color="$GREEN"
    if [[ "$status" != "running" ]]; then
      status_color="$YELLOW"
    fi
    if [[ -n "$health" && "$health" != "healthy" ]]; then
      status_color="$RED"
    fi

    printf '%b\n' "${BOLD}Service:${RESET} ${name}"
    printf '  %bState:%b    %b%s%b' "$BOLD" "$RESET" "$status_color" "$status" "$RESET"
    if [[ -n "$health" ]]; then
      printf ' (health: %s)\n' "$health"
    else
      printf ' (no explicit healthcheck)\n'
    fi

    echo "  ${BOLD}Mounts:${RESET}"
    local mounts
    mounts=$(docker inspect --format '{{range .Mounts}}{{.Type}}: {{.Source}} -> {{.Destination}}{{"\n"}}{{end}}' "$id" || true)
    if [[ -z "$mounts" ]]; then
      echo "    (no mounts found)"
    else
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        echo "    $line"
      done <<<"$mounts"
    fi
    echo
  done
}

#############################################
# Argument parsing
#############################################

CMD=""

if [[ $# -eq 0 ]]; then
  usage
  exit 0
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    start|restart|stop|rebuild|clean|logs|shell|info|status|health)
      if [[ -n "$CMD" ]]; then
        error "Multiple commands specified: '$CMD' and '$1'. Use only one."
      fi
      CMD="$1"
      shift
      ;;
    --profile)
      shift
      [[ $# -gt 0 ]] || error "--profile requires a value"
      set_target_mode "profile"
      parse_csv_append "$1" PROFILES
      shift
      ;;
    --service|--services)
      shift
      [[ $# -gt 0 ]] || error "--service requires a value"
      set_target_mode "service"
      parse_csv_append "$1" SERVICES
      shift
      ;;
    --all)
      if [[ "${#PROFILES[@]}" -gt 0 || "${#SERVICES[@]}" -gt 0 ]]; then
        error "--all cannot be combined with --profile or --service"
      fi
      TARGET_MODE="all"
      shift
      ;;
    -f|--file)
      shift
      [[ $# -gt 0 ]] || error "--file requires a value"
      COMPOSE_FILE="$1"
      shift
      ;;
    -p|--project-name)
      shift
      [[ $# -gt 0 ]] || error "--project-name requires a value"
      PROJECT_NAME="$1"
      shift
      ;;
    --version)
      echo "stackctl.sh v${SCRIPT_VERSION}"
      exit 0
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      FORWARDED_ARGS=("$@")
      break
      ;;
    *)
      error "Unknown argument: $1"
      ;;
  esac
done

ensure_command_set

#############################################
# Dispatch
#############################################

case "$CMD" in
  start)   cmd_start   ;;
  restart) cmd_restart ;;
  stop)    cmd_stop    ;;
  rebuild) cmd_rebuild ;;
  clean)   cmd_clean   ;;
  logs)    cmd_logs    ;;
  shell)   cmd_shell   ;;
  info)    cmd_info    ;;
  status)  cmd_status  ;;
  health)  cmd_health  ;;
  *)       error "Unhandled command: $CMD" ;;
esac

exit 0

